var DialogBase = require('AFDialogBase');
import PointItem from './PointItem';

const SPRITETYPE = cc.Enum({
    unlock: 0,
    locking: 1,
    lock: 2,
    gift: 3,
});

const shareType = cc.Enum({
    select: 1,
    unSelect: 0
});

const pointWidth = 79;
const pointHeight = 83;
const rowNum = 5;
const colNum = 10;
let pointNum = 400;
let doctColPadding = 13; // 下面点的间距
const allPoint = colNum * rowNum; // 一页的方块总数，便于后续计算
let allPageNum = Math.ceil(pointNum / allPoint) - 1; // 一共多少页
let renderList = [];

cc.Class({
    extends: DialogBase,

    properties: {
        bg: cc.Node,
        pageView: cc.Node, // 当前页面的视图
        scrollView: cc.ScrollView, // 滚动条自身
        item: cc.Prefab, //  关卡 View
        content: cc.Node, // 滚动条内容
        view: cc.Node,  // 滚动条可见试图
        scrolldoctView: cc.Node,  // 底部画布
    },

    // LIFE-CYCLE CALLBACKS:

    onLoad: function () {
        DialogBase.prototype.onLoad.call(this);
        this.rowPadding = (this.view.width - pointWidth * rowNum) / (rowNum - 1);
        this.colPadding = (this.view.height - pointHeight * colNum) / (colNum - 1);
        this.doctR = 16;
        this.nowPoint = 123; // 当前第几关, 下标
        this.contPageId = Math.ceil(this.nowPoint / allPoint) - 1; // 当前是第几页
        if (this.contPageId + 1 < allPageNum) {
            allPageNum = this.contPageId + 1
        }
        this.moveDirection = 'left'; // 滑动的方向
        this.scorllFlag = false; // 是否允许滚动
        this.doctY = this.scrolldoctView.height / 2; // 底部原点的 y 坐标
        this.parentViewW = this.view.width; // 父组件view的宽度
        this.parentViewH = this.view.height; // 父组件view的高度
        this.spacing = (this.pageView.width - this.parentViewW) / 2; // 父组件距离页面的边距
        this.content.width = (this.contPageId + 2) * this.parentViewW + (this.contPageId + 1) * (this.spacing + this.rowPadding); // content的长度
        pointNum = pointNum > (this.contPageId + 2) * allPoint ? (this.contPageId + 2) * allPoint : pointNum
        this.initUI();

        // 如果底部的原点长度大于底部框，就缩小半径和间距
        var doctViewW = allPageNum * this.doctR * 2 + (allPageNum - 1) * doctColPadding; // 底部原点的宽度
        while (doctViewW > this.scrolldoctView.width) {
            this.doctR /= 2;
            doctColPadding /= 2;
            doctViewW = allPageNum * this.doctR * 2 + (allPageNum - 1) * doctColPadding; // 底部原点的宽度
        }
        this.doctFirstX = (this.scrolldoctView.width - doctViewW) / 2 + this.doctR; // 底部原点第一个 X 坐标
        this.initData(this.contPageId, true);
        this.initDoct();
        this.scrollView.node.on('scrolling', this.movingCB, this); //滚动视图正在滚动时发出的事件
        this.scrollView.node.on('scroll-began', this.startCB, this);  // 滚动视图滚动开始时发出的事件
        this.scrollView.node.on('scroll-ended', this.movedCB, this);  // 滚动视图滚动开始时发出的事件
    },

    onEnable: function () {
        DialogBase.prototype.onEnable.call(this);
    },

    initUI: function () {
        //适配iPhoneX，bg沉到最底下
        //this.bg.y = (this.bg.height - cc.winSize.height)/2;
        this.bg.y = (0 - cc.winSize.height) / 2
    },

    // 监听滚动条开始滚动
    startCB(e) {
        this.scorllFlag = true;
        this.firstX = this.scrollView.getComponent(cc.ScrollView).getScrollOffset().x;
        // console.log('滚动开始', this.firstX)
        if (renderList[this.contPageId - 1] !== 1) {
            this.initData(this.contPageId - 1)
        }
        if (renderList[this.contPageId + 1] !== 1) {
            this.initData(this.contPageId + 1)
        }
    },

    // 监听滚动条滚动
    movingCB(e) {
        let movex = this.scrollView.getComponent(cc.ScrollView).getScrollOffset().x;
        // console.log('滚动zhong  = ', this.firstX, movex)
        if (this.firstX < movex) {
            this.moveDirection = 'left'
        } else {
            this.moveDirection = 'right'
        }
    },

    // 监听滚动条结束滚动
    movedCB(e) {
        // console.log('滚动结束', this.scorllFlag)
        if (this.scorllFlag && this.firstX !== 0) {
            switch (this.moveDirection) {
                case 'left':
                    // console.log('左滑')
                    this.contPageId !== 0 ? this.contPageId-- : 0;
                    break;
                case 'right':
                    // console.log('右滑', this.contPageId, Math.ceil(pointNum / allPoint) - 1);
                    this.contPageId !== Math.ceil(pointNum / allPoint) - 1 ? this.contPageId++ : this.contPageId;
                    break;
            }
            // console.log('this.contPageId = ', this.contPageId);
            this.scorllFlag = false;
            // 更新UI
            this.initDoct()
        }
    },

    // 画关卡
    initData: function (page, firstFlag = false) {
        // console.log('渲染了 = ', page, firstFlag, this.content.width)
        if (page < 0 || page > allPageNum) return;
        const nowPointNum = page < allPageNum ? allPoint : pointNum - allPoint * allPageNum;
        for (let index = 0; index < nowPointNum; index++) {
            let z1 = page * (this.parentViewW + this.rowPadding + this.spacing) + pointWidth / 2;
            let z2 = pointHeight / 2;
            let x = Math.floor(index % rowNum) * (pointWidth + this.rowPadding) + z1;
            let y = Math.floor(index / rowNum) * (pointHeight + this.colPadding) + z2;
            let _i = allPoint * page + index;
            let labelName = String(_i + 1);
            let _color = SPRITETYPE.lock;
            if (_i < this.nowPoint) {
                _color = SPRITETYPE.unlock;
            } else if (_i === this.nowPoint) {
                _color = SPRITETYPE.locking;
            } else if (_i > this.nowPoint && (_i + 1)  % 25 === 0) {
                _color = SPRITETYPE.gift
            }
            this.addItem(x, -y, labelName, _color);
        }

        if (page !== 0 && firstFlag) {
            setTimeout(() => {
                this.changeScrollTo();
            }, 50)
        }
        renderList[page] = 1
    },

    addItem(x, y, labelName, color) {
        // console.log(x, y, labelName);
        var a = cc.instantiate(this.item);
        var pointItem = a.getComponent(PointItem);
        pointItem.setPointLabel(labelName, this.nowPoint, color, () => {
            this.close()
        });
        a.x = x;
        a.y = y;
        pointItem.name = 'pointItem_' + labelName;
        a.parent = this.content
    },

    // 画底部小圆点 & 更新
    initDoct() {
        this.changeScrollTo();
        this.scrolldoctView.removeAllChildren(true);
        for (let i = 0; i <= allPageNum; i++) {
            var node = new cc.Node('Sprite' + i);
            var sp = node.addComponent(cc.Sprite);
            if (i !== this.contPageId) {
                sp.spriteFrame = new cc.SpriteFrame(cc.url.raw('resources/hall/textures/fill/point/doct1.png'));
                sp.node.width = 33;
                sp.node.height = 33;
            } else {
                sp.spriteFrame = new cc.SpriteFrame(cc.url.raw('resources/hall/textures/fill/point/doct.png'));
                sp.node.width = 27;
                sp.node.height = 27;
            }
            sp.node.x = (2 * this.doctR + doctColPadding) * i + this.doctFirstX;
            sp.node.y = this.scrolldoctView.height / 2;
            node.parent = this.scrolldoctView;
        }
    },

    // 滑动  条
    changeScrollTo() {
        this.scrollView.scrollToOffset(cc.p(this.contPageId * (this.parentViewW + this.spacing + this.rowPadding), 0), 0.5);
    },

    onBackButtonClick: function (event, custom) {
        this.close();
    }
});
